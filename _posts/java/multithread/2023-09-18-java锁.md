---
Title: Java 多线程锁
Date: 2023-09-18 23:00:00
Tags: [Java, 多线程, 锁]
---

# JAVA 中锁的特性

Java 中常见的锁有几种重要的锁实现方式，如：synchronized 、 ReentrantLock 、 ReentrantReadWriteLoc，可以根据下面的几种性质对这几种锁进行描述

- 自旋锁：是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。

---

- 乐观锁：假定没有冲突，在修改数据时如果发现数据和之前获取的不一致，则读最新数据，修改后重试修改
- 悲观锁：假定会发生并发冲突，同步所有对数据的相关操作，从读数据就开始上锁。

---

- 独享锁（写）：给资源加上写锁，线程可以修改资源，其他线程不能冉加锁；（单写）
- 共享锁（读）：给资源加上读锁后只能读不能改，其他线程也只能加读锁，不能加写锁；（多读）

---

- 可重入锁、不可重入锁：线程拿到一把锁之后，该线程可以自由进入同一把锁所同步的其他代码为可重入锁，否则为不可重入锁。

---

- 公平锁、非公平锁：争抢锁的顺序，如果是按先来后到，则为公平。

# 几种锁的类型

## 偏向锁

## 轻量级锁

## 重量级锁

# synchronized 关键字

1. 用于实例方法、静态方法时，隐式指定锁对象
2. 用于代码块时，显示指定锁对象
3. 锁的作用域：对象锁、类锁、分布式锁
4. 引申：如果是多个进程，怎么办？

---

特性：可重入、独享、悲观锁

---

锁优化：

锁消除：JIT 对锁的一种优化，利用逃逸分析技术判断锁对象是否只被一个线程访问，如果是的话就取消上锁的过程。开启锁消除的参数： -XX:+DoEscapeAnalysis -XX:+EliminateLocks，

锁粗化： JDK 做了锁粗化的优化，将多次细粒度的锁合并为一次锁，但我们自己可从代码层面优化

---

JMM 中规定:

synchronized 要保证可见性（不能够被缓存），在修改了本地内存中的变量后，解锁前会将本地内存修改的内容刷新到主内存中，确保了共享变量的值是最新的，也就保证了可见性。

