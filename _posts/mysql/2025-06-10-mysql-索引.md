# mysql select 执行过程

## 一次简单MySQL select的总体过程

1. 连接器
    1. 客户端连接MySQL服务，一般是使用TCP进行连接的，三次握手
    2. 经过TCP握手成功后，验证账户密码，
    3. 连接器（MySQL server 内部）获取用户权限并缓存权限
2. 查询缓存（MySQL8已弃用）
    MySQL8已经删了，鸡肋，因为只要表更新缓存就失效
3. 解析器解析SQL
    词法分析，语法分析，生成语法树
4. 预处理器
    检查 SQL 查询语句中的表或者字段是否存在
    将 select * 中的 * 符号，扩展为表上的所有列
5. 优化器，
    负责生成优化执行计划，也就是负责将 SQL 查询语句的执行方案确定下来
    例如会根据**索引**等进行考量，使用explain可以看到执行计划
6. 执行器
    和存储引擎交互，从存储引擎读取记录，返回给客户端


## 修改权限会影响已有连接的权限么？不会
如果用户密码都没有问题，连接器就会获取该用户的权限，然后保存起来，后续该用户在此连接里的任何操作，都会基于连接开始时读到的权限进行权限逻辑的判断。所以，如果一个用户已经建立了连接，即使管理员中途修改了该用户的权限，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。

## 如何查看 MySQL 服务被多少个客户端连接了？
show processlist

## 空闲连接会一直占用着吗？
不是，MySQL 定义了空闲连接的最大空闲时长，由 wait_timeout 参数控制的，默认值是 8 小时（28800 秒），如果空闲连接超过了这个时间，连接器就会自动将它断开。
一个处于空闲状态的连接被服务端主动断开后，这个客户端并不会马上知道，等到客户端在发起下一个请求的时候，才会收到这样的报错“ERROR 2013 (HY000): Lost connection to MySQL server during query”。



##  MySQL 的连接数有限制吗？
MySQL 服务支持的最大连接数由 max_connections 参数控制，比如我的 MySQL 服务默认是 151 个，超过这个值，系统就会拒绝接下来的连接请求，并报错提示“Too many connections”。

## MySQL长短连接的区别
```text
// 短连接
连接 mysql 服务（TCP 三次握手）
执行sql
断开 mysql 服务（TCP 四次挥手）

// 长连接
连接 mysql 服务（TCP 三次握手）
执行sql
执行sql
执行sql
....
断开 mysql 服务（TCP 四次挥手）
```

## 长连接优点缺点
好处就是可以减少建立连接和断开连接的过程
坏处是长连接后可能会占用内存增多，因为 MySQL 在执行查询过程中临时使用内存管理连接对象，这些连接对象资源只有在连接断开时才会释放。如果长连接累计很多，将导致 MySQL 服务占用内存太大，有可能会被系统强制杀掉，这样会发生 MySQL 服务异常重启的现象

## 怎么解决长连接占用内存的问题
第一种，定期断开长连接。
第二种，客户端主动重置连接。MySQL 5.7 版本实现了 mysql_reset_connection() 函数的接口，注意这是接口函数不是命令，那么当客户端执行了一个很大的操作后，在代码里调用 mysql_reset_connection 函数来重置连接，达到释放内存的效果。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。

# 事务
## 事务的特性

原子性（Atomicity）：一个事务中的所有操作，要么全部完成，要么全部不完成，而且事务在执行过程中发生错误或者取消，会被回滚到事务开始前的状态。
一致性（Consistency）：是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态（和业务有关）。
隔离性（Isolation）：多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。也就是说，消费者购买商品这个事务，是不影响其他消费者购买的。
持久性（Durability）：事务处理结束后，就应该被持久化到磁盘
C是通过AID实现的

## InnoDB 引擎通过什么技术来保证事务的这四个特性

持久性是通过 redo log （重做日志）来保证的；
原子性是通过 undo log（回滚日志） 来保证的；
隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；
一致性则是通过持久性+原子性+隔离性来保证；


## 标准SQL的隔离级别

严重怀疑xiaolincoding的表述有误
读未提交（read uncommitted），指一个事务还没提交时，它做的变更就能被其他事务看到；
（read committed），指一个事务提交之后，它做的变更才能被其他事务看到；
可重复读（repeatable read），指一个事务执行过程中看到的数据，跟第一次读取时看到的是一致的；
串行化（serializable ）；事务就像是依次、串行地按照提交顺序执行，而不是并发执行一样

其实看https://www.postgresql.org/docs/current/transaction-iso.html，串行化可能也是有问题的

## MySQL隔离级别
MySQL实现了标准SQL的隔离级别，但是略有区别
MySQL 在「可重复读」隔离级别下，可以很大程度上避免幻读现象的发生
MySQL的串行化性能很差，MySQL 在 SERIALIZABLE 下会强制所有读都加共享锁（S锁）；所有写都加排他锁（X锁）；是通过 悲观锁机制 来防止并发冲突；一旦有读写冲突时，事务会阻塞，并发性能很差。

1. 读未提交：每次都读最新的就好了
2. 串行化：强制所有读都加共享锁（S锁），所有写都加排他锁（X锁）
3. 读提交： Read View 实现的，「每个语句执行前」都会重新生成一个 Read View
4. 可重复读：Read View 实现的，启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View

注意，执行「begin/start transaction」命令，并不意味着启动了事务，默认执行了第一条 select 语句，才是事务真正启动的时机。
执行 start transaction with consistent snapshot 命令，才马上启动事务。

## mvcc


# 锁
## 间隙锁
https://blog.csdn.net/Tomwildboar/article/details/134342139


# 索引
## 覆盖索引

索引覆盖是数据库查询优化的一个重要概念，它指的是当一个查询可以仅通过索引就能获取所需的所有数据，而无需回到数据表中去查找。在这种情况下，索引已经“覆盖”了查询所需要的数据，因此可以显著提高查询效率。

索引覆盖的工作原理

在理解索引覆盖之前，我们需要明白索引本身的作用。索引是帮助数据库高效找到数据行的一种结构，类似于书本的目录。如果一个查询所需的数据已经在索引中，数据库就无需再去数据行中检索，这样就减少了I/O操作，提高了查询速度。例如，如果一个查询只需要某个已经被索引的列的数据，那么这个索引就是一个覆盖索引。

如何实现索引覆盖

要实现索引覆盖，通常的做法是将查询中涉及的所有列都包含在索引中。这可以通过创建复合索引来实现，即一个索引包含多个列。例如，在MySQL中，如果我们对查询中使用的列建立了索引，那么在执行计划中的Extra字段会显示Using index，这表明查询使用了索引覆盖。

在实际应用中，如果我们知道某个查询会频繁发生，且查询的列不多，那么可以针对这些列创建一个复合索引。这样，当查询发生时，数据库可以直接使用索引中的数据，而不需要回表查询，从而提高查询性能。

索引覆盖的优势

索引覆盖的主要优势在于它避免了回表查询，这是一种情况，其中数据库需要从非主键索引找到主键，然后再回到主键索引去检索完整的数据行。通过使用覆盖索引，可以直接从非主键索引中获取所需数据，减少了查询步骤和I/O操作，从而提高了查询效率。

注意事项

值得注意的是，并不是所有类型的索引都可以用于索引覆盖。例如，哈希索引、空间索引和全文索引不存储索引列的值，因此不能用于索引覆盖。在MySQL中，通常使用B-tree索引来实现索引覆盖。

总的来说，索引覆盖是数据库性能优化的有效手段之一。在设计数据库和查询时，应当考虑是否可以利用索引覆盖来提高性能，特别是在处理大量数据和复杂查询时，索引覆盖的优势尤为明显。

## mysql的btree hash fulltext  rtree索引有什么区别


B-Tree索引
    默认索引类型，适用于等值查询和范围查询（如>、<、BETWEEN）。
    支持ORDER BY排序和最左前缀匹配（联合索引）。
    适用于InnoDB和MyISAM存储引擎。
Hash索引
    仅支持等值查询（=、IN），不支持范围查询或排序。
    查询速度极快，时间复杂度接近O(1)。
    仅Memory存储引擎显式支持，InnoDB的自适应哈希索引是隐式的。
Fulltext索引
    专用于全文搜索，支持文本内容的模糊匹配（MATCH AGAINST）。
    仅适用于MyISAM和InnoDB（MySQL 5.6+）。
    需要分词处理，适合大文本字段（如文章内容）。
R-Tree索引
    用于空间数据类型（如GEOMETRY），支持地理范围查询（如MBRContains）。
    仅MyISAM存储引擎支持。
    适用于GIS应用（如地图坐标检索）。

核心差异：

    B-Tree通用性强，Hash速度快但功能受限，Fulltext针对文本，R-Tree针对空间数据。
    存储引擎支持不同，需根据场景选择。
## 索引下
索引下推能够减少二级索引在查询时的回表操作，提高查询的效率，因为它将 Server 层部分负责的事情，交给存储引擎层去处理了。
联合索引当遇到范围查询 (>、<) 就会停止匹配




# 日志


# 存储结构
比较综合，后续再看

# 内存