---
Title: MySQL常见知识点整理
Date: 2025-06-10 22:29:00
Tags: [MySQL,数据库]
---

# mysql select 执行过程

## 一次简单MySQL select的总体过程

1. 连接器
    1. 客户端连接MySQL服务，一般是使用TCP进行连接的，三次握手
    2. 经过TCP握手成功后，验证账户密码，
    3. 连接器（MySQL server 内部）获取用户权限并缓存权限
2. 查询缓存（MySQL8已弃用）
    MySQL8已经删了，鸡肋，因为只要表更新缓存就失效
3. 解析器解析SQL
    词法分析，语法分析，生成语法树
4. 预处理器
    检查 SQL 查询语句中的表或者字段是否存在
    将 `select *`中的 `*` 符号，扩展为表上的所有列
5. 优化器，
    负责生成优化执行计划，也就是负责将 SQL 查询语句的执行方案确定下来
    例如会根据**索引**等进行考量，使用explain可以看到执行计划
6. 执行器
    和存储引擎交互，从存储引擎读取记录，返回给客户端

## 修改权限会影响已有连接的权限么？不会

如果用户密码都没有问题，连接器就会获取该用户的权限，然后保存起来，后续该用户在此连接里的任何操作，都会基于连接开始时读到的权限进行权限逻辑的判断。
所以，如果一个用户已经建立了连接，即使管理员中途修改了该用户的权限，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。

## 如何查看 MySQL 服务被多少个客户端连接了？

show processlist

## 空闲连接会一直占用着吗？

不是，MySQL 定义了空闲连接的最大空闲时长，由 wait_timeout 参数控制的，默认值是 8 小时（28800 秒），如果空闲连接超过了这个时间，连接器就会自动将它断开。
一个处于空闲状态的连接被服务端主动断开后，这个客户端并不会马上知道，等到客户端在发起下一个请求的时候，才会收到这样的报错“ERROR 2013 (HY000): Lost connection to MySQL server during query”。

## MySQL 的连接数有限制吗？

MySQL 服务支持的最大连接数由 max_connections 参数控制，比如我的 MySQL 服务默认是 151 个，超过这个值，系统就会拒绝接下来的连接请求，并报错提示“Too many connections”。

## MySQL长短连接的区别

```text
// 短连接
连接 mysql 服务（TCP 三次握手）
执行sql
断开 mysql 服务（TCP 四次挥手）

// 长连接
连接 mysql 服务（TCP 三次握手）
执行sql
执行sql
执行sql
....
断开 mysql 服务（TCP 四次挥手）
```

## 长连接优点缺点

好处就是可以减少建立连接和断开连接的过程
坏处是长连接后可能会占用内存增多，因为 MySQL 在执行查询过程中临时使用内存管理连接对象，这些连接对象资源只有在连接断开时才会释放。如果长连接累计很多，将导致 MySQL 服务占用内存太大，有可能会被系统强制杀掉，这样会发生 MySQL 服务异常重启的现象

## 怎么解决长连接占用内存的问题

第一种，定期断开长连接。
第二种，客户端主动重置连接。MySQL 5.7 版本实现了 mysql_reset_connection() 函数的接口，注意这是接口函数不是命令，那么当客户端执行了一个很大的操作后，在代码里调用 mysql_reset_connection 函数来重置连接，达到释放内存的效果。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。

# 事务

## 事务的特性

* 原子性（Atomicity）：一个事务中的所有操作，要么全部完成，要么全部不完成，而且事务在执行过程中发生错误或者取消，会被回滚到事务开始前的状态。
* 一致性（Consistency）：是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态（和业务有关）。
* 隔离性（Isolation）：多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。也就是说，消费者购买商品这个事务，是不影响其他消费者购买的。
* 持久性（Durability）：事务处理结束后，就应该被持久化到磁盘
C是通过AID实现的

## InnoDB 引擎通过什么技术来保证事务的这四个特性

持久性是通过 redo log （重做日志）来保证的；
原子性是通过 undo log（回滚日志） 来保证的；
隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；
一致性则是通过持久性+原子性+隔离性来保证；

## 标准SQL的隔离级别

严重怀疑xiaolincoding的表述有误

* 读未提交（read uncommitted），指一个事务还没提交时，它做的变更就能被其他事务看到；
* 读已提交（read committed），指一个事务提交之后，它做的变更才能被其他事务看到；
* 可重复读（repeatable read），指一个事务执行过程中看到的数据，跟第一次读取时看到的是一致的；
* 串行化（serializable ）；事务就像是依次、串行地按照提交顺序执行，而不是并发执行一样

其实看<https://www.postgresql.org/docs/current/transaction-iso.html>，串行化可能也是有问题的，但是没有时间深究了

## MySQL隔离级别

MySQL实现了标准SQL的隔离级别，但是略有区别。

MySQL 在「可重复读」隔离级别下，可以很大程度上避免幻读现象的发生（靠的是间隙锁）

MySQL的串行化性能很差，MySQL 在 SERIALIZABLE 下会强制所有读都加共享锁（S锁）；所有写都加排他锁（X锁）；是通过 悲观锁机制 来防止并发冲突；一旦有读写冲突时，事务会阻塞，并发性能很差。

简而言之，在不同的隔离级别下，MySQL的读取方式如下

1. 读未提交：每次都读最新的就好了
2. 串行化：强制所有读都加共享锁（S锁），所有写都加排他锁（X锁）
3. 读提交： Read View 实现的，「每个语句执行前」都会重新生成一个 Read View
4. 可重复读：Read View 实现的，启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View

注意：

1. 执行「begin/start transaction」命令，并不意味着启动了事务
2. 默认执行了第一条 select 语句，才是事务真正启动的时机。
3. 执行 start transaction with consistent snapshot 命令，才马上启动事务。

## mvcc

# 锁

## 全局锁

`flush tables with read lock`，执行后，整个数据库就处于只读状态了。

对数据的增删改操作，比如 `insert`、`delete`、`update`等；
对表结构的更改操作，比如 `alter table`、`drop table` 等都会被阻塞。

`unlock tables`解锁，连接断开也会自动释放

全局锁主要应用于做全库逻辑备份，防止因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。

### 如何避免全局锁期间业务停滞

全局锁期间，业务只能读数据，而不能更新数据，这样会造成业务停滞。

如果数据库的引擎支持的事务支持**可重复读**的隔离级别，那么在备份数据库之前先**开启事务**，会先创建 Read View，然后整个事务执行期间都在用这个 Read View，而且由于 **MVCC** 的支持，备份期间业务依然可以对数据进行更新操作。

如`mysqldump`，在使用 `mysqldump` 时加上 `–single-transaction` 参数的时候，就会在备份数据库之前先开启事务。这种方法只适用于支持「**可重复读**隔离级别的事务」的存储引擎。

## 表锁

### 读锁

`lock tables t_student read;`

表级别的共享锁，也就是读锁，允许当前会话读取被锁定的表，但阻止其他会话对这些表进行写操作：

读锁限制了别的线程写，其他线程写会堵塞。

读锁也会限制本线程对这个表的写入，写入的时候会报错。

读锁限制本线程不能访问其他表，否则会报错，除非其他表也被锁了，如`LOCK TABLES table1 READ, table2 READ, table3 READ;`

事务和表锁不兼容

释放读锁：unlock tables或者退出会话，或者在执行新的 LOCK TABLES 前，旧的锁会被自动释放。

### 写锁

`lock tables t_stuent write;`

表级别的独占锁，也就是写锁，允许当前会话对表进行读写操作，但阻止其他会话对这些表进行任何操作（读或写）：

读锁限制了别的线程读写，其他线程读写会堵塞。

读锁限制本线程不能访问其他表，否则会报错，除非其他表也被锁了，如`LOCK TABLES table1 READ, table2 READ, table3 write;`

事务和表锁不兼容

释放读锁：unlock tables或者退出会话，或者在执行新的 LOCK TABLES 前，旧的锁会被自动释放。

### 元数据锁MDL

元数据锁是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。

无需直接使用，对数据库表进行操作时，会自动给这个表加上 MDL：

* 对一张表进行 CRUD 操作时，加的是 MDL 读锁；
* 对一张表做结构变更操作的时候，加的是 MDL 写锁；

MDL 是在事务提交后才会释放

#### 长事务对MDL的影响

申请 MDL 锁的操作会形成一个队列，队列中写锁获取优先级高于读锁，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。

举例而言：
首先，线程 A 先启用了事务（但是一直不提交），然后执行一条 select 语句，此时就先对该表加上 MDL 读锁；

然后，线程 B 也执行了同样的 select 语句，此时并不会阻塞，因为「读读」并不冲突；

接着，线程 C 修改了表字段，此时由于线程 A 的事务并没有提交，也就是 MDL 读锁还在占用着，这时线程 C 就无法申请到 MDL 写锁，就会被阻塞，

在C之后的所有MDL读锁都会被阻塞，因为写锁的优先级高，但是C的写锁被A的长事务占用了。

### 意向锁

参考<https://zhuanlan.zhihu.com/p/185003485>

简单而言，意向锁是InnoDB自身一种内部优化，用于在加表锁之前判断这个表是否已经有行锁。

每次加入行锁的时候，InnoDB都会自动加入意向锁（表锁），所有在加真的表锁（读写锁）的时候，通过判断有无意向锁就知道是否需要阻塞了。

### AUTO-INC 锁

AUTO-INC 锁是特殊的表锁机制，在插入数据时，会加一个表级别的 AUTO-INC 锁，然后为被 AUTO_INCREMENT 修饰的字段赋值递增的值，等插入语句执行完成后，才会把 AUTO-INC 锁释放掉。

锁不是再一个事务提交后才释放，而是再**执行完插入语句**后就会**立即释放**。

显然，对于一个表的插入都是依赖于这个锁的，因此大量插入会影响性能。

因此现在的MySQL有了一个可选的优化innodb_autoinc_lock_mode ：
在插入数据的时候，会为被 AUTO_INCREMENT 修饰的字段加上轻量级锁，然后给该**字段**赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁。

看到区别了没有，不用完成一个插入，只需要给字段赋值就释放了，会比之前性能好很多。缺点是并发大的时候可能会出现交错的ID，也就是**不保证连续**。

innodb_autoinc_lock_mode =0，传统锁模式（legacy），所有的插入都使用AUTO_INC表级锁
innodb_autoinc_lock_mode =1，连续锁模式，对于“Simple inserts”使用轻量互斥锁，对于“bulk inserts”类语句使用AUTO_INC表级锁。主从复制可以保证一致（简单而言，因为锁的存在，一条语句执行的结果ID必然是连续的，binlog也是按顺序记录的，所以复制后也必然连续）。
innodb_autoinc_lock_mode =2，交错锁模式(MySQL8默认) ，所有的insert都用轻量级锁。缺点：基于语句复制会有问题，只能使用基于ROW复制（MySQL8默认）。

注：<https://dev.mysql.com/doc/refman/8.0/en/innodb-auto-increment-handling.html>
“Simple inserts”：指在插入前就能确定插入行数的语句，包括：INSERT、REPLACE，不包含INSERT…ON DUPLICATE KEY UPDATE这类语句。

“Bulk inserts”：指在插入前不能确定行数的语句，包括：INSERT ... SELECT/REPLACE ... SELECT/LOAD DATA。

## 行锁

TODO：这里整理的比较烂

InnoDB 支持行锁， MyISAM 不支持

```sql
//对读取的记录加共享锁
select ... lock in share mode;

//对读取的记录加独占锁
select ... for update;
```

行级锁的类型主要有三类：

1. Record Lock，记录锁，也就是仅仅把一条记录锁上；
2. Gap Lock，间隙锁，锁定一个范围，但是不包含记录本身；
3. Next-Key Lock：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身

### Record Lock（记录锁）

锁住的是一条记录。而且记录锁是有 S 锁和 X 锁之分的

### Gap Lock（间隙锁）

**只存在于可重复读隔离级别**，目的是为了解决可重复读隔离级别下**幻读**的现象。

间隙锁是对一个索引值之间的“间隙”加锁，而不是对具体的某一行数据加锁。防止其他事务在这个“间隙”中插入新的记录。保证当前事务在执行期间不会看到新增的“幻影行”。

假设数据库里有1，3，5这三条元素

```sql
INSERT INTO t VALUES (1, 'Alice'), (3, 'Bob'), (5, 'Charlie');
START TRANSACTION;
SELECT * FROM t WHERE id BETWEEN 2 AND 4 FOR UPDATE;
```

这个查询会锁定索引中 id 在 2 到 4 之间的所有记录和间隙 ，即：

锁定 id=3 这一行（record lock）
锁定 (1,3) 和 (3,5) 之间的间隙（gap lock）
尝试对被锁定的记录和间隙进行修改会被阻塞

<https://blog.csdn.net/Tomwildboar/article/details/134342139>

### Next-Key Lock

InnoDB 为了支持 可重复读 事务隔离级别，在执行范围查询（如 SELECT ... WHERE age > 10 AND age < 20 FOR UPDATE）时加上的一种锁，防止幻读。

在 REPEATABLE READ 隔离级别下，范围查询 + FOR UPDATE / LOCK IN SHARE MODE 就会触发 Next-Key Lock

为什么叫 “Next-Key”？因为它锁的是： 当前记录 + 它前面的间隙，相当于左开右闭区间

举个简单的例子

```sql
CREATE TABLE users (
  id INT AUTO_INCREMENT PRIMARY KEY,
  age INT,
  name VARCHAR(100)
) ENGINE=InnoDB;

-- 数据：
+----+-----+
| id | age |
+----+-----+
| 1  | 10  |
| 2  | 20  |
| 3  | 30  |
+----+-----+
```

```sql
START TRANSACTION;
SELECT * FROM users WHERE age > 10 AND age < 30 FOR UPDATE;
```

InnoDB 采用 Next-Key Lock，会加锁：(10, 20]和(20, 30]，
不让其他事务在这些间隙中插入新数据，以防幻读

* 一个更具体的例子，GPT告诉我的，没有做实验验证
我们用如下表结构和数据为例：

```sql
CREATE TABLE t (
  id INT PRIMARY KEY,
  age INT,
  name VARCHAR(20),
  KEY(age) -- 普通索引
) ENGINE=InnoDB;

-- 初始数据：
INSERT INTO t VALUES 
(1, 10, 'A'),
(2, 20, 'B'),
(3, 30, 'C'),
(4, 40, 'D');
```

1. 示例 1：范围查询 + FOR UPDATE（Next-Key Lock）

```sql
-- 事务A
START TRANSACTION;
SELECT * FROM t WHERE age > 10 AND age < 40 FOR UPDATE;
```

🔒 加锁情况（Next-Key Lock）：

    (10,20]：锁住 gap 和 age=20

    (20,30]：锁住 gap 和 age=30

    (30,40]：锁住 gap 和 age=40

共锁住：三段范围和三个记录

2. 示例 2：精确查找唯一主键（Record Lock）

```sql
-- 事务A
START TRANSACTION;
SELECT * FROM t WHERE id = 2 FOR UPDATE;
```

这是主键查询（唯一索引 + 精确匹配）
🔒 加锁情况：

    仅加 Record Lock：id = 2

不会加间隙锁，不影响其他记录插入。

3. 示例 3：非唯一索引查找 + 等值（Next-Key Lock）

```sql
-- 事务A
START TRANSACTION;
SELECT * FROM t WHERE age = 30 FOR UPDATE;
```

age 是普通二级索引（非唯一），即使是等值，也会触发 Next-Key Lock。
🔒 加锁情况：

    (20,30]：锁住 age=30 和前间隙（因为InnoDB中没有(30,30]这种范围）

⚠️ 虽然是等值查找，但仍然是范围扫描（相当于age >= 30 AND age <= 30） → 用 Next-Key Lock！

4. 示例 4：没有用索引（全表扫描）+ WHERE 条件（Record Lock）

```sql
-- 事务A
START TRANSACTION;
SELECT * FROM t WHERE name = 'C' FOR UPDATE;
```

name 没有索引，InnoDB 只能走主键全表扫描。
🔒 加锁情况：

    找到满足条件的记录（id=3），加 Record Lock

    不加间隙锁（因为是通过主键一条条判断）

5.  示例 5：唯一索引 + 范围查找（Next-Key Lock）

```sql
-- 事务A
START TRANSACTION;
SELECT * FROM t WHERE id > 2 AND id < 4 FOR UPDATE;
```

然是唯一索引（主键），但这是范围查找，会加 Next-Key Lock。
🔒 加锁范围：

    (2,3]：锁住 id=3 和 gap

    (3,4]：锁住 id=4 和 gap

6. 示例 6：auto_increment 列上的间隙锁（插入意图锁）

```sql
-- 表结构不同：
CREATE TABLE auto_t (
  id INT AUTO_INCREMENT PRIMARY KEY,
  name VARCHAR(10)
) ENGINE=InnoDB;

-- 当前最大 id = 5
```

```sql
-- 事务A
START TRANSACTION;
INSERT INTO auto_t(name) VALUES ('A');
```

🔒 加锁：

    插入意图锁：加在 (5, +∞) 的 gap 上，用于生成下一个 AUTO_INCREMENT 值（MySQL 使用了插入意图锁 + AUTO-INC机制）

这是 另一种间隙锁应用场景。

### Insert Intention Lock （插入意向锁）

InnoDB 为了协调插入操作之间的并发，在 等待 gap lock 时自动加上的一种意向锁。
是 一种特殊的 gap lock，但本质上是非阻塞的插入声明，不会冲突，也不会阻止其他插入。

假设一个查询操作锁住了（10，20）这个间隙，但是一个插入操作想插入一条15的数据，InnoDB就会自动加上“插入意向锁”，表示要在（10，20）这个gap插入数据。

假设A事务想插入15，B事务想插入16， 二者的插入意向锁，并不会冲突
假设A事务想插入15，B事务想插入15， 二者的插入意向锁，也不会冲突

真正决定是否“冲突”的，不是插入意向锁，而是：

    是否有其他事务持有了 gap lock（间隙锁） → 阻止插入；

    是否违反唯一约束（如 PRIMARY KEY 或 UNIQUE） → 插入失败或等待；

    是否因为事务串行化而等待锁释放（如锁 wait）。

# 索引

## 覆盖索引

索引覆盖是数据库查询优化的一个重要概念，它指的是当一个查询可以仅通过索引就能获取所需的所有数据，而无需回到数据表中去查找。在这种情况下，索引已经“覆盖”了查询所需要的数据，因此可以显著提高查询效率。

索引覆盖的工作原理

在理解索引覆盖之前，我们需要明白索引本身的作用。索引是帮助数据库高效找到数据行的一种结构，类似于书本的目录。如果一个查询所需的数据已经在索引中，数据库就无需再去数据行中检索，这样就减少了I/O操作，提高了查询速度。例如，如果一个查询只需要某个已经被索引的列的数据，那么这个索引就是一个覆盖索引。

如何实现索引覆盖

要实现索引覆盖，通常的做法是将查询中涉及的所有列都包含在索引中。这可以通过创建复合索引来实现，即一个索引包含多个列。例如，在MySQL中，如果我们对查询中使用的列建立了索引，那么在执行计划中的Extra字段会显示Using index，这表明查询使用了索引覆盖。

在实际应用中，如果我们知道某个查询会频繁发生，且查询的列不多，那么可以针对这些列创建一个复合索引。这样，当查询发生时，数据库可以直接使用索引中的数据，而不需要回表查询，从而提高查询性能。

索引覆盖的优势

索引覆盖的主要优势在于它避免了回表查询，这是一种情况，其中数据库需要从非主键索引找到主键，然后再回到主键索引去检索完整的数据行。通过使用覆盖索引，可以直接从非主键索引中获取所需数据，减少了查询步骤和I/O操作，从而提高了查询效率。

注意事项

值得注意的是，并不是所有类型的索引都可以用于索引覆盖。例如，哈希索引、空间索引和全文索引不存储索引列的值，因此不能用于索引覆盖。在MySQL中，通常使用B-tree索引来实现索引覆盖。

总的来说，索引覆盖是数据库性能优化的有效手段之一。在设计数据库和查询时，应当考虑是否可以利用索引覆盖来提高性能，特别是在处理大量数据和复杂查询时，索引覆盖的优势尤为明显。

## mysql的btree hash fulltext  rtree索引有什么区别

B-Tree索引
    默认索引类型，适用于等值查询和范围查询（如>、<、BETWEEN）。
    支持ORDER BY排序和最左前缀匹配（联合索引）。
    适用于InnoDB和MyISAM存储引擎。
Hash索引
    仅支持等值查询（=、IN），不支持范围查询或排序。
    查询速度极快，时间复杂度接近O(1)。
    仅Memory存储引擎显式支持，InnoDB的自适应哈希索引是隐式的。
Fulltext索引
    专用于全文搜索，支持文本内容的模糊匹配（MATCH AGAINST）。
    仅适用于MyISAM和InnoDB（MySQL 5.6+）。
    需要分词处理，适合大文本字段（如文章内容）。
R-Tree索引
    用于空间数据类型（如GEOMETRY），支持地理范围查询（如MBRContains）。
    仅MyISAM存储引擎支持。
    适用于GIS应用（如地图坐标检索）。

核心差异：

    B-Tree通用性强，Hash速度快但功能受限，Fulltext针对文本，R-Tree针对空间数据。
    存储引擎支持不同，需根据场景选择。

## 索引下推

索引下推能够减少二级索引在查询时的回表操作，提高查询的效率，因为它将 Server 层部分负责的事情，交给存储引擎层去处理了。
联合索引当遇到范围查询 (>、<) 就会停止匹配

# 日志

# 存储结构

比较综合，后续再看

# 内存

## Statement-based replication（SBR）如何保证一致？
